Bonus For Question-4
__________________________________________________________________________________________________________________
| Opcode | Instruction | Semantics                                    | Syntax                | Type             |
|--------|-------------|----------------------------------------------|-----------------------|------------------|
| 10100  | decf        | Decrement a register if the value is not zero| decf reg1             | Type -S          |
|        |             | otherwise overflow flag is set               |                       |                  |
|--------|-------------|----------------------------------------------|-----------------------|------------------|
| 10101  | incf        | Increment a register if the value is not     | incf reg1             | Type-S           |
|        |             | 2^16 otherwise overflow flag is set          |                       |                  |
|--------|-------------|----------------------------------------------|-----------------------|------------------|
| 10110  | swap        | Swap content of registers                    | swap reg1 reg2        | Type-C           |
|--------|-------------|----------------------------------------------|-----------------------|------------------|
| 10111  | clr         | Clear a register                             | clr reg1              | Type-S           |
|--------|-------------|----------------------------------------------|-----------------------|------------------|
| 11000  | bsf         | Set the given bit in the given file register | bsf reg1 $Imm         | Type- L          |
_________________________________________________________________________________________________________________

Binary Encoding:
The ISA has 3 types of instructions with distinct encoding styles. However, each instruction is of 16 bits, regardless of the type.


Type -S: 1 Register Type 
 __________________________________________________________
| Opcode(5 bits)    | Unused (8 bits) | Register (3 bits) |
|-------------------|---------------- |-------------------|
| 15 14 13 12 11    |10 9 8 7 6 5 4 3 | 2 1 0             |
|-------------------|---------------- |-------------------|
___________________________________________________________

Type - C: 2 Register Type
_______________________________________________________________
| Opcode(5 bits)    | Unused(5 bits)  | reg1(3 bits) | reg2    |
|-------------------|-----------------|--------------|---------|
|  15 14 13 12 11   | 10 9 8 7 6      | 5 4 3        | 2  1  0 |
_______________________________________________________________

Type - L: Register and Immediate Value Type
_______________________________________________________________________________
| Opcode(5 bits)    | Unused(4 bits)  | reg1(3 bits) | Imm(Bit Address)(4bits )|
|-------------------|-----------------|--------------|-------------------------|
|  15 14 13 12 11   | 10 9 8 7        | 6 5 4        | 3 2  1  0               |
________________________________________________________________________________


FLAGS semantics:
The semantics of the flags register are:
● Overflow (V): This flag is set by {add, sub, mul, div,decf,incf} when the result of the operation
overflows. This shows the overflow status for the last executed instruction.

● Less than (L): This flag is set by the “cmp reg1 reg2” instruction if reg1 < reg2
● Greater than (G): This flag is set by the “cmp reg1 reg2” instruction if the value of
reg1 > reg2
● Equal (E): This flag is set by the “cmp reg1 reg2” instruction if reg1 = reg2
The default state of the FLAGS register is all zeros. If an instruction does not set the
FLAGS register after the execution, the FLAGS register is reset to zeros.
The structure of the FLAGS register is as follows:
________________________________________________
| Unused (12 bits)             | V | L | G | E |
|----------------------------- |---|---|---|---|
| 15 14 13 12 11 10 9 8 7 6 5 4| 3 | 2 | 1 | 0 |
_______________________________________________


=========================
TEST CASES FOR ASSEMBLER
=========================

TEST CASE 1:
add R0 R1 R2
add R1 R5 R2
add R2 R3 R4
decf R1
incf R3
hlt
OUTPUT TESTCASE 1:
0000000000001010
0000000001101010
0000000010011100
1010000000000001
1010100000000011
1101000000000000

TEST CASE 2:
mov R1 R2
add R1 R2 R3
incf R2
clr R1
bsf R1 $10
hlt
OUTPUT TESTCASE 2:
0001100000001010
0000000001010011
1010100000000010
1011100000000001
1100000000011010
1101000000000000

TEST CASE 3:
var xyz
var abc
l1: mov R0 $5
mov R1 $6
mov R5 FLAGS
incf R4
swap R1 R5
bsf R4 $11
bsf R1 $10
l_2:	st R0 xyz
	add R0 R0 R1
    decf R3
    bsf R2 $9
	ld R2 abc
	je l1
	jgt l_2
hlt
OUTPUT TESTCASE 3:
0001000000000101
0001000010000110
0001100000101111
1010100000000100
1011000000001101
1100000001001011
1100000000011010
0010100000001111
0000000000000001
1010000000000011
1100000000101001
0010000100010000
1111100000000000
1110100000000111
1101000000000000

TEST CASE 4:
incf R4
swap R1 R5
bsf R4 $11
bsf R1 $10
add R0 R0 R1
decf R3
bsf R2 $9
incf R1
incf R2
incf R3
incf R4
incf R5
incf R6
decf R2
decf R3
decf R4
decf R5
decf R6
bsf R1 $7
bsf R2 $9
bsf R2 $10
bsf R2 $12
bsf R2 $9
hlt
OUTPUT TESTCASE 4:
1010100000000100
1011000000001101
1100000001001011
1100000000011010
0000000000000001
1010000000000011
1100000000101001
1010100000000001
1010100000000010
1010100000000011
1010100000000100
1010100000000101
1010100000000110
1010000000000010
1010000000000011
1010000000000100
1010000000000101
1010000000000110
1100000000010111
1100000000101001
1100000000101010
1100000000101100
1100000000101001
1101000000000000

TEST CASE 5:
var xyz
var abc
l1: mov R0 $5
mov R1 $6
mov R5 FLAGS
incf R4
swap R1 R5
bsf R4 $11
bsf R1 $10
l_2:	st R0 xyz
	add R0 R0 R1
    decf R3
    bsf R2 $9
	ld R2 abc
	je l1
	jgt l_2
l_3:
    	st R0 xyz
	add R0 R0 R1
    decf R3
    bsf R2 $9
	ld R2 abc
	je l1
	jgt l_2
hlt
OUTPUT TESTCASE 5:
0001000000000101
0001000010000110
0001100000101111
1010100000000100
1011000000001101
1100000001001011
1100000000011010
0010100000010111
0000000000000001
1010000000000011
1100000000101001
0010000100011000
1111100000000000
1110100000000111
0010100000010111
0000000000000001
1010000000000011
1100000000101001
0010000100011000
1111100000000000
1110100000000111
1101000000000000

=========================
TEST CASES FOR SIMULATOR
=========================
Test Case 1 
0001000010000101
0001000010000101
0001000010000101
0001000010000101
0001000010000101
0001000010000101
1010100000000100
1011100000000001
1101000000000000

Test Case 2
0000100000001010
0000100010011100
0000100011001101
0000100000001010
1010100000000100
1010100000000100
1011000000100101
1010000000000101
1101000000000000

Test Case 3
1010100000000001
1010000000000001
1010000000000001
1100000000110011
1101000000000000

Test Case 4
1010100000000100
1011100000000001
1101000000000000
1010100000000100
1011100000000001
1101000000000000
0001000010000101
0001000010000101
0001000010000101
0001000010000101
0001000010000101
0001000010000101
1010100000000100
1011100000000001
1101000000000000
1010100000000100
1011100000000001
1101000000000000

Test Case 5
1010100000000100
0001000010000101
1011100000000001
1101000000000000
1010100000000100
1011100000000001
1101000000000000
0001000010000101
0001000010000101
1011100000000001
1101000000000000
1010100000000100
1011100000000001
1101000000000000
1011100000000001
1101000000000000
1010100000000100
1011100000000001
1101000000000000


